/**
 * Copyright 2024-2025 agentic15.com
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * TaskIssueMapper - Maps task data to GitHub issue format
 *
 * Single Responsibility: Convert between task and issue representations
 *
 * This class provides static methods for mapping task JSON structure
 * to GitHub issue format (title, body, labels).
 */
export class TaskIssueMapper {
  /**
   * Generate GitHub issue title from task
   *
   * @param {Object} task - Task object
   * @returns {string} Issue title
   */
  static taskToIssueTitle(task) {
    return `[${task.id}] ${task.title}`;
  }

  /**
   * Generate GitHub issue body from task using issue template format
   *
   * @param {Object} task - Task object
   * @returns {string} Issue body in markdown format
   */
  static taskToIssueBody(task) {
    // Follow .github/ISSUE_TEMPLATE/task.md structure
    let body = `## Task Description\n\n`;

    if (task.description) {
      body += `${task.description}\n\n`;
    }

    if (task.estimatedHours) {
      body += `**Estimated Hours:** ${task.estimatedHours}h\n\n`;
    }

    body += `## Phase\n\n`;
    body += `${task.phase || 'implementation'}\n\n`;

    body += `## Dependencies\n\n`;
    if (task.dependencies && task.dependencies.length > 0) {
      task.dependencies.forEach(dep => {
        body += `- ${dep}\n`;
      });
    } else {
      body += `*No dependencies*\n`;
    }

    body += `\n## Completion Criteria\n\n`;
    if (task.completionCriteria && task.completionCriteria.length > 0) {
      task.completionCriteria.forEach(criteria => {
        body += `- [ ] ${criteria}\n`;
      });
    } else {
      body += `*No specific criteria defined*\n`;
    }

    // Add TDD requirements based on task phase
    if (task.phase === 'testing') {
      body += `\n## Test Requirements (if testing task)\n\n`;
      body += `**For Testing Tasks:**\n`;
      body += `- [ ] Tests are REAL and EXECUTABLE (no mocks/placeholders)\n`;
      body += `- [ ] Tests verify actual functionality (not just pass by default)\n`;
      body += `- [ ] Positive test cases included\n`;
      body += `- [ ] Negative test cases included\n`;
      body += `- [ ] Edge cases covered\n`;
      body += `- [ ] Error conditions tested\n\n`;

      // Add UI or Backend specific requirements based on test cases
      const hasUITests = task.testCases?.some(tc =>
        tc.toLowerCase().includes('ui') ||
        tc.toLowerCase().includes('component') ||
        tc.toLowerCase().includes('render') ||
        tc.toLowerCase().includes('form') ||
        tc.toLowerCase().includes('navigation')
      );

      const hasBackendTests = task.testCases?.some(tc =>
        tc.toLowerCase().includes('api') ||
        tc.toLowerCase().includes('endpoint') ||
        tc.toLowerCase().includes('response') ||
        tc.toLowerCase().includes('status')
      );

      if (hasUITests) {
        body += `**For UI Testing Tasks:**\n`;
        body += `- [ ] User interactions verified\n`;
        body += `- [ ] Component state changes tested\n`;
        body += `- [ ] Visual rendering validated\n`;
        body += `- [ ] Form validation tested\n`;
        body += `- [ ] Navigation flows tested\n\n`;
      }

      if (hasBackendTests) {
        body += `**For Backend Testing Tasks:**\n`;
        body += `- [ ] API responses verified\n`;
        body += `- [ ] Data validation tested\n`;
        body += `- [ ] Error handling validated\n`;
        body += `- [ ] Status codes correct\n\n`;
      }
    }

    if (task.phase === 'implementation') {
      body += `\n## Implementation Requirements (if implementation task)\n\n`;
      body += `**For Implementation Tasks:**\n`;
      body += `- [ ] Prerequisite testing task completed\n`;
      body += `- [ ] All tests from prerequisite task pass\n`;
      body += `- [ ] Code satisfies test requirements\n`;
      body += `- [ ] No breaking changes to existing tests\n\n`;
    }

    if (task.testCases && task.testCases.length > 0) {
      body += `## Test Cases\n\n`;
      task.testCases.forEach(test => {
        body += `- ${test}\n`;
      });
      body += `\n`;
    }

    body += `---\n*Auto-generated by Agentic15 Claude Zen*`;

    return body;
  }

  /**
   * Map task status and phase to GitHub labels
   *
   * @param {string} status - Task status (pending, in_progress, completed, blocked)
   * @param {string|null} phase - Task phase (design, implementation, testing, etc.)
   * @returns {string[]} Array of label names
   */
  static taskStatusToLabels(status, phase = null) {
    const labels = [];

    // Status labels
    switch (status) {
      case 'pending':
        labels.push('status: pending');
        break;
      case 'in_progress':
        labels.push('status: in-progress');
        break;
      case 'completed':
        labels.push('status: completed');
        break;
      case 'blocked':
        labels.push('status: blocked');
        break;
    }

    // Phase labels
    if (phase) {
      const phaseLabel = this.phaseToLabel(phase);
      if (phaseLabel) {
        labels.push(phaseLabel);
      }
    }

    return labels;
  }

  /**
   * Convert phase name to GitHub label
   *
   * @param {string} phase - Phase name
   * @returns {string} Label name
   */
  static phaseToLabel(phase) {
    const phaseLabels = {
      'design': 'phase: design',
      'implementation': 'phase: implementation',
      'testing': 'phase: testing',
      'deployment': 'phase: deployment',
      'documentation': 'phase: documentation'
    };

    return phaseLabels[phase] || `phase: ${phase}`;
  }
}
